<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <script>
      var data = {
        name: 'poetry',
        age: {
          name: '111',
        },
      };
      observe(data);
      let name = data.name; // -> get value
      data.name = 'yyy'; // -> change value
      data.age.name = 222;
      function observe(obj) {
        // 判断类型
        if (!obj || typeof obj !== 'object') {
          //只有对象类型才能定义响应式属性
          return;
        }
        Object.keys(data).forEach(key => {
          defineReactive(obj, key, obj[key]); //data表示的是对象本身,注意要是迭代之后的对象      key表示的是属性   data[key]表示的是值
        });
      }

      function defineReactive(obj, key, val) {
        // 递归子属性
        observe(val); //如果属性的值是一个对象，那么这个对象的属性也会被设置为响应式属性。
        Object.defineProperty(obj, key, {
          //对obj这个对象上面的key属性设置get和set的响应式
          enumerable: true, //是否通过for...in循环或Object.keys方法返回
          configurable: true, //是否可以修改属性的描述符或删除属性
          get: function reactiveGetter() {
            console.log('get value');
            return val;
          },
          set: function reactiveSetter(newVal) {
            console.log('change value');
            val = newVal; //***********易错点也是需要注意的点    因为这这个对象当中使用后的是递归的方法去更新的值，所以不能直接使用obj[key]=  这样的方法去更新值
          },
        });
      }
    </script>
  </body>
</html>
